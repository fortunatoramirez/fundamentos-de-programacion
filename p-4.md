# Práctica 4 — Funciones y Arreglos 1D en C++ con datos biomédicos

> **Propósito.** Diseñar programas **modulares** usando **funciones** y **arreglos** para capturar, validar y procesar conjuntos de datos reales (ej. lecturas fisiológicas), con salidas claras y reutilizables.

---

## 1) Objetivo general

Aplicar **funciones** (prototipos, retorno, parámetros por valor y por referencia) y **arreglos 1D** para resolver problemas reales de captura, validación y análisis básico de datos.

---

## 2) Marco teórico

### 2.1 Funciones en C++

* **Prototipo:** declara firma antes de `main`.

  ```cpp
  double imc(double peso, double estatura); // prototipo
  ```
* **Definición:** implementa la lógica.
* **Parámetros por valor:** copian el dato (no modifican el original).
* **Parámetros por referencia (`&`):** permiten **modificar** el argumento real.

  ```cpp
  void stats(const double a[], int n, double& minimo, double& maximo, double& promedio);
  ```
* **`const` en parámetros:** garantiza no modificar (seguridad semántica).
* **Alcance (scope):** variables definidas dentro de una función son **locales**.

### 2.2 Arreglos (vectores) 1D

* **Declaración:** `double lecturas[100];`
* **Índices:** `0..n-1`. ¡Cuidado con **límites**!
* **Inicialización y recorrido:** usar `for`.
* **Tamaño lógico vs. tamaño físico:** `n` (cuántos datos válidos) puede ser menor al tamaño reservado.

### 2.3 Buenas prácticas

* **Constantes:** umbrales clínicos, IVA, etc.
* **Funciones pequeñas y reutilizables.**
* **Validaciones de rango** antes de calcular.

---

## 3) Desarrollo de la práctica

En cada bloque:

1. **Pseudocódigo**
2. **Diagrama de flujo (guía)**
3. **Código C++**

> Diagramas: [diagrams.net](https://www.diagrams.net/).
> Símbolos: Inicio/Fin, Entrada, Proceso, Decisión, Salida, Llamada a subproceso (función).

---

## 4) Bloques de actividades

### Bloque 1 — Modularizar: funciones puras reutilizables

**Problema real:** Hospital quiere funciones estándar:

* `celsiusAFahrenheit(c)`
* `calcularIMC(peso, estatura)`

**Pseudocódigo**

```
FUNC celsiusAFahrenheit(c): RETORNAR c*9/5 + 32
FUNC calcularIMC(peso, est): RETORNAR peso/(est*est)

INICIO
  LEER tempC, peso, est
  tempF ← celsiusAFahrenheit(tempC)
  imc   ← calcularIMC(peso, est)
  ESCRIBIR tempF, imc
FIN
```

**Diagrama (guía):** Inicio → Entradas → Llamar f1/f2 → Salidas → Fin.

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

double celsiusAFahrenheit(double c){ return c*9.0/5.0 + 32.0; }
double calcularIMC(double peso, double est){ return peso/(est*est); }

int main(){
    double tempC, peso, est;
    cin >> tempC >> peso >> est;
    cout << fixed << setprecision(2);
    cout << "F: " << celsiusAFahrenheit(tempC) << "\n";
    cout << "IMC: " << calcularIMC(peso, est) << "\n";
    return 0;
}
```

---

### Bloque 2 — Validación como función booleana

**Problema real:** Verificar si una **temperatura** en °C es **plausible** (30–45).

**Pseudocódigo**

```
FUNC esTempPlausible(T): RETORNAR (T>30 Y T<45)

INICIO
  LEER T
  SI esTempPlausible(T) ENTONCES ESCRIBIR "OK"
  SINO ESCRIBIR "No plausible"
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

bool esTempPlausible(double T){ return (T>30.0 && T<45.0); }

int main(){
    double T; cin >> T;
    cout << (esTempPlausible(T) ? "OK\n" : "No plausible\n");
    return 0;
}
```

---

### Bloque 3 — Parámetros por referencia: mínimo, máximo y promedio

**Problema real:** Dadas **N lecturas de presión** (mmHg) sistólica de triage, obtener **min**, **max** y **promedio** saltando valores fuera de rango (80–220).

**Pseudocódigo**

```
PROC statsPresion(a[], n, min, max, prom)  // min,max,prom por referencia
  suma ← 0; cont ← 0
  min ← +INF; max ← -INF
  PARA i=0..n-1
    SI (a[i] >= 80 Y a[i] <= 220) ENTONCES
       suma ← suma + a[i]
       si a[i] < min entonces min ← a[i]
       si a[i] > max entonces max ← a[i]
       cont ← cont + 1
  FIN_PARA
  SI cont>0 ENTONCES prom ← suma/cont SINO prom ← 0
FIN_PROC

INICIO
  LEER n y lecturas
  LLAMAR statsPresion(...)
  ESCRIBIR min, max, prom
FIN
```

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
#include <limits>
using namespace std;

void statsPresion(const double a[], int n, double& mn, double& mx, double& prom){
    double suma=0; int cont=0;
    mn = numeric_limits<double>::infinity();
    mx = -numeric_limits<double>::infinity();
    for(int i=0;i<n;i++){
        if(a[i]>=80 && a[i]<=220){
            suma += a[i];
            if(a[i]<mn) mn=a[i];
            if(a[i]>mx) mx=a[i];
            cont++;
        }
    }
    prom = (cont>0)? suma/cont : 0.0;
}

int main(){
    int n; cin >> n;
    const int MAX=200;
    double x[MAX];
    for(int i=0;i<n;i++) cin >> x[i];

    double mn,mx,prom;
    statsPresion(x,n,mn,mx,prom);
    cout << fixed << setprecision(1);
    if(mn==numeric_limits<double>::infinity()) cout << "No hay datos validos\n";
    else cout << "Min: "<<mn<<"  Max: "<<mx<<"  Prom: "<<prom<<"\n";
    return 0;
}
```

---

### Bloque 4 — Captura validada en arreglo (do-while por elemento)

**Problema real:** Capturar **N** lecturas de **glucosa** (mg/dL) válidas en `40–500`. Reintentar cada posición hasta que cumpla.

**Pseudocódigo**

```
PROC capturarGlucosa(g[], n)
  PARA i=0..n-1
    REPETIR
      LEER valor
      valido ← (40 ≤ valor ≤ 500)
    HASTA valido
    g[i] ← valor
  FIN_PARA
FIN_PROC

INICIO
  LEER n
  LLAMAR capturarGlucosa(g,n)
  ESCRIBIR "OK"
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

void capturarGlucosa(double g[], int n){
    for(int i=0;i<n;i++){
        double v; bool ok;
        do{
            cout << "g["<<i<<"] (40-500): ";
            cin >> v;
            ok = (v>=40 && v<=500);
            if(!ok) cout << "Fuera de rango. Intente de nuevo.\n";
        }while(!ok);
        g[i]=v;
    }
}

int main(){
    int n; cin >> n;
    const int MAX=300; double g[MAX];
    capturarGlucosa(g,n);
    cout << "Lecturas capturadas correctamente.\n";
    return 0;
}
```

---

### Bloque 5 — Conteo por rangos clínicos en arreglo

**Problema real:** Con las lecturas válidas de glucosa, contar:

* **Hipoglucemia** `<70`
* **Normal** `70–140`
* **Hiperglucemia** `>140`

**Pseudocódigo**

```
PROC conteosGlucosa(g[], n, hipo, normal, hiper) // por referencia
  hipo←0; normal←0; hiper←0
  PARA i=0..n-1
    SI g[i] < 70 ENTONCES hipo++
    SINO SI g[i] <= 140 ENTONCES normal++
    SINO hiper++
  FIN_PARA
FIN_PROC
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

void conteosGlucosa(const double g[], int n, int& hipo, int& normal, int& hiper){
    hipo=normal=hiper=0;
    for(int i=0;i<n;i++){
        if(g[i]<70) hipo++;
        else if(g[i]<=140) normal++;
        else hiper++;
    }
}

int main(){
    int n; cin >> n;
    double g[300];
    for(int i=0;i<n;i++) cin >> g[i];
    int hipo, normal, hiper;
    conteosGlucosa(g,n,hipo,normal,hiper);
    cout << "Hipoglucemia: "<<hipo<<"  Normal: "<<normal<<"  Hiper: "<<hiper<<"\n";
    return 0;
}
```

---

### Bloque 6 — Búsqueda: primer valor fuera de rango (índice)

**Problema real:** En un lote de **temperaturas** de equipo, hallar el **primer** valor **no plausible** (30–45). Si todos son válidos, devolver `-1`.

**Pseudocódigo**

```
FUNC primerNoPlausible(t[], n):
  PARA i=0..n-1
    SI (t[i] ≤ 30 O t[i] ≥ 45) RETORNAR i
  FIN_PARA
  RETORNAR -1
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

int primerNoPlausible(const double t[], int n){
    for(int i=0;i<n;i++)
        if(t[i]<=30.0 || t[i]>=45.0) return i;
    return -1;
}

int main(){
    int n; cin >> n;
    double t[300];
    for(int i=0;i<n;i++) cin >> t[i];
    int idx = primerNoPlausible(t,n);
    if(idx==-1) cout << "Todos plausibles\n";
    else cout << "No plausible en indice " << idx << " (valor="<<t[idx]<<")\n";
    return 0;
}
```

---

### Bloque 7 — Inventario simple con `switch` y funciones

**Problema real (manufactura):** Dado un **tipo de insumo** (`A` alcohol, `G` guantes, `M` mascarillas), y una **cantidad** a registrar (entrada/salida), actualizar el **stock**.

**Pseudocódigo**

```
PROC actualizar(stockA, stockG, stockM, tipo, delta) // por referencia
  SEGUN(tipo)
    'A'|'a': stockA ← stockA + delta
    'G'|'g': stockG ← stockG + delta
    'M'|'m': stockM ← stockM + delta
    OTRO: ESCRIBIR "Tipo no valido"
  FIN_SEGUN
FIN_PROC

INICIO
  LEER stockA, stockG, stockM
  LEER tipo, delta
  LLAMAR actualizar(...)
  ESCRIBIR stockA, stockG, stockM
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

void actualizar(int& A, int& G, int& M, char tipo, int delta){
    switch(tipo){
        case 'A': case 'a': A += delta; break;
        case 'G': case 'g': G += delta; break;
        case 'M': case 'm': M += delta; break;
        default: cout << "Tipo no valido\n";
    }
}

int main(){
    int A,G,M; cin >> A >> G >> M;
    char t; int d; cin >> t >> d;
    actualizar(A,G,M,t,d);
    cout << "Stock -> Alcohol:"<<A<<" Guantes:"<<G<<" Mascarillas:"<<M<<"\n";
    return 0;
}
```

---

## 5) Ejercicio integrador (sin pseudocódigo ni código aquí)

**Monitor modular de signos y consumibles**

Construir un programa **100% modular** con estas funciones (mínimo):

1. `bool esTempPlausible(double T)`
2. `double calcularIMC(double peso, double est)`
3. `void capturarLecturas(double a[], int n, double minVal, double maxVal)`
4. `void stats(const double a[], int n, double& mn, double& mx, double& prom)`
5. `int primerFueraDeRango(const double a[], int n, double minVal, double maxVal)`
6. `void actualizarStock(int& A, int& G, int& M, char tipo, int delta)`

**Requisitos del sistema:**

* **Menú** (`do-while` + `switch`) con opciones:

  * Capturar N temperaturas y validar (usa 1,3).
  * Mostrar min/max/prom de temperaturas (usa 4).
  * Detectar primer valor fuera de rango (usa 5).
  * Calcular IMC de un paciente (usa 2).
  * Actualizar stock de insumos (usa 6).
  * Salir.
* **Constantes** para umbrales (`const double T_MIN=30, T_MAX=45;`).
* **Arreglo** para las temperaturas (p. ej., 200 máx).
* **Entregables:**

  * Pseudocódigo del menú y de **cada** función.
  * Diagramas (uno del menú general + uno de una función a elección).
  * Capturas de ejecución (todas las opciones).
  * Pruebas con **datos límites** (p. ej., T=30, 45).

---

## 6) Preguntas de reflexión

1. Explica con tus palabras la diferencia entre **parámetro por valor** y **por referencia**.
2. ¿Por qué conviene usar `const` en parámetros de solo lectura? Da un ejemplo.
3. ¿Qué riesgos existen al **salirse del rango** de un arreglo?
4. ¿Cómo dividirías un programa grande en **módulos** (funciones) para facilitar pruebas y mantenimiento?

---

## 7) Evidencias para la bitácora

* Pseudocódigo(s) y **diagramas** de cada bloque.
* **Capturas de ejecución** (mínimo 1 por bloque; varias en el integrador).
* Respuestas a las **preguntas de reflexión**.

---

## 8) Compilación y ejecución (recordatorio)

```bash
g++ -std=c++17 main.cpp -o main
./main
```

En Code::Blocks: **F9**.

