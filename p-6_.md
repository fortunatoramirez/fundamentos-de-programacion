# Práctica 6 — Juego en consola con estructuras, vectores, archivos y eventos temporizados

Propósito. Integrar los conocimientos aprendidos en las prácticas anteriores mediante la construcción de un juego interactivo en consola que utilice estructuras (`struct`), vectores dinámicos, manejo de archivos, temporizadores y funciones modulares.

---

## 1) Objetivo general

Desarrollar un juego en consola utilizando estructuras, vectores, funciones, archivos, eventos controlados por tiempo y representación gráfica básica mediante coordenadas, construyendo un sistema modular, claro y mantenible.

---

## 2) Marco teórico (resumen)

Se mantiene la descripción de:

* `struct` para agrupar datos del jugador, enemigos, objetos.
* `std::vector` para manejar listas dinámicas.
* `<fstream>` para guardar y cargar archivos.
* `<chrono>` para medir tiempo sin detener el programa.
* Representación en consola con un mapa 2D y el uso de coordenadas (`gotoxy`).

(Si quieres luego, puedo agregarte un marco teórico más largo; aquí lo mantengo compacto para no saturar.)

---

## 3) Desarrollo por bloques

En cada bloque:

1. Se indica el objetivo.
2. Se da una breve guía de lo que hace.
3. Se presenta un **código completo** que compila.

Los alumnos pueden ir sustituyendo el código anterior por el nuevo de cada bloque.

---

### Bloque 1 — Mapa estático y jugador dibujado en consola

Objetivo del bloque
Definir las estructuras básicas y mostrar un mapa estático en consola con un jugador en una posición fija.

Qué se logra en este bloque

* Definir `struct Jugador`.
* Crear un mapa como `vector<string>`.
* Dibujar mapa y jugador.

#### Código completo del Bloque 1

```cpp
// Bloque 1: Mapa estático y jugador dibujado
// Compilar en Windows (Code::Blocks, g++, etc.)

#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Estructura para el jugador
struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

// Función para dibujar el mapa y el jugador
void dibujar(const vector<string>& mapa, const Jugador& j) {
    system("cls"); // Limpia pantalla (Windows)
    // Dibujar mapa línea por línea
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            if (x == j.x && y == j.y)
                cout << '@';   // Jugador
            else
                cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
}

int main() {
    // Mapa sencillo: # = pared, espacio = zona libre
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#                  #",
        "#      ####        #",
        "#                  #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#                  #",
        "####################"
    };

    Jugador jugador;
    jugador.x = 2;
    jugador.y = 2;
    jugador.vida = 100;
    jugador.puntos = 0;

    dibujar(mapa, jugador);

    cout << "\n(Bloque 1) Mapa dibujado. Presione ENTER para terminar.\n";
    cin.get();
    return 0;
}
```

---

### Bloque 2 — Movimiento del jugador con WASD y colisión con paredes

Objetivo del bloque
Permitir que el jugador se mueva con las teclas `W`, `A`, `S`, `D`, impidiendo que atraviese paredes.

Qué se agrega

* Bucle principal de juego.
* Lectura de teclas (aquí, sencilla: el alumno debe presionar tecla y luego ENTER).
* Lógica de colisiones con paredes.

> Nota: En este bloque se usa entrada bloqueante (cin). Más adelante se agrega entrada no bloqueante con `<conio.h>`.

#### Código completo del Bloque 2

```cpp
// Bloque 2: Movimiento del jugador con WASD (entrada con ENTER)
// Compilar en Windows (Code::Blocks, g++, etc.)

#include <iostream>
#include <vector>
#include <string>

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

void dibujar(const vector<string>& mapa, const Jugador& j) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            if (x == j.x && y == j.y)
                cout << '@';
            else
                cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Mover con WASD + ENTER, q + ENTER para salir.\n";
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#                  #",
        "#      ####        #",
        "#                  #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#                  #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};

    char tecla;
    do {
        dibujar(mapa, jugador);
        cout << "Tecla: ";
        cin >> tecla;
        if (tecla == 'q' || tecla == 'Q') break;
        moverJugador(jugador, tecla, mapa);
    } while (true);

    return 0;
}
```

---

### Bloque 3 — Bucle con entrada no bloqueante y temporizador básico

Objetivo del bloque
Hacer que el juego sea más “en tiempo real” usando:

* Bucle de juego continuo.
* Entrada no bloqueante con `_kbhit()` y `_getch()` de `<conio.h>`.
* Temporizador general `millis()` usando `<chrono>`.

Qué se agrega

* Función `millis()`.
* Uso de `_kbhit()` y `_getch()` para leer teclas sin detener el programa.

#### Código completo del Bloque 3

```cpp
// Bloque 3: Entrada no bloqueante y temporizador básico
// Compilar en Windows (requiere <conio.h>)

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <conio.h>   // _kbhit, _getch

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

unsigned long millis() {
    using namespace chrono;
    return duration_cast<milliseconds>(
        steady_clock::now().time_since_epoch()
    ).count();
}

void dibujar(const vector<string>& mapa, const Jugador& j) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            if (x == j.x && y == j.y)
                cout << '@';
            else
                cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Mover con WASD. Tecla 'q' para salir.\n";
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#                  #",
        "#      ####        #",
        "#                  #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#                  #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};

    bool corriendo = true;
    unsigned long tInicio = millis();

    while (corriendo) {
        // 1) Procesar entrada (si hay)
        if (_kbhit()) {
            char tecla = _getch();
            if (tecla == 'q' || tecla == 'Q') {
                corriendo = false;
            } else {
                moverJugador(jugador, tecla, mapa);
            }
        }

        // 2) Dibujar
        dibujar(mapa, jugador);

        // 3) Mostrar tiempo transcurrido
        unsigned long ahora = millis();
        unsigned long segundos = (ahora - tInicio) / 1000;
        cout << "Tiempo: " << segundos << " s\n";

        // Pequeña pausa para no saturar la CPU
        // (no es estrictamente necesaria, pero ayuda)
        this_thread::sleep_for(chrono::milliseconds(50));
    }

    return 0;
}
```

> Nota: para usar `this_thread::sleep_for` debe agregarse `#include <thread>` arriba. Si no quieres usar sleep, puedes quitar esa línea y el juego seguirá funcionando, solo consumirá más CPU.

---

### Bloque 4 — Enemigo con movimiento automático (estructura Enemigo)

Objetivo del bloque
Agregar un enemigo que se mueve solo cada cierto tiempo usando el temporizador.

Qué se agrega

* `struct Enemigo`.
* Movimiento automático basado en `millis()`.

#### Código completo del Bloque 4

```cpp
// Bloque 4: Enemigo con movimiento automático
// Compilar en Windows

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <conio.h>

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

struct Enemigo {
    int x;
    int y;
    int dx; // cambio en x
    int dy; // cambio en y
    unsigned long ultimaActualizacion;
};

unsigned long millis() {
    using namespace chrono;
    return duration_cast<milliseconds>(
        steady_clock::now().time_since_epoch()
    ).count();
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

void moverEnemigo(Enemigo& e, const vector<string>& mapa, unsigned long intervalo) {
    unsigned long ahora = millis();
    if (ahora - e.ultimaActualizacion >= intervalo) {
        int nx = e.x + e.dx;
        int ny = e.y + e.dy;

        // Si choca con pared, invertir dirección
        if (esPared(mapa, nx, ny)) {
            e.dx = -e.dx;
            e.dy = -e.dy;
        } else {
            e.x = nx;
            e.y = ny;
        }
        e.ultimaActualizacion = ahora;
    }
}

void dibujar(const vector<string>& mapa, const Jugador& j, const Enemigo& e) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            if (x == j.x && y == j.y)
                cout << '@';     // jugador
            else if (x == e.x && y == e.y)
                cout << 'X';     // enemigo
            else
                cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Mover con WASD. 'q' para salir.\n";
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#                  #",
        "#      ####        #",
        "#                  #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#                  #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};
    Enemigo enemigo;
    enemigo.x = 15;
    enemigo.y = 5;
    enemigo.dx = -1;
    enemigo.dy = 0;
    enemigo.ultimaActualizacion = millis();

    bool corriendo = true;

    while (corriendo) {
        // Entrada
        if (_kbhit()) {
            char tecla = _getch();
            if (tecla == 'q' || tecla == 'Q') {
                corriendo = false;
            } else {
                moverJugador(jugador, tecla, mapa);
            }
        }

        // Movimiento del enemigo
        moverEnemigo(enemigo, mapa, 300); // 300 ms

        // Colisión jugador-enemigo
        if (jugador.x == enemigo.x && jugador.y == enemigo.y) {
            jugador.vida -= 1; // daño pequeño continuo
            if (jugador.vida <= 0) {
                corriendo = false;
            }
        }

        // Dibujar
        dibujar(mapa, jugador, enemigo);

        this_thread::sleep_for(chrono::milliseconds(40));
    }

    system("cls");
    if (jugador.vida <= 0)
        cout << "Juego terminado: te quedaste sin vida.\n";
    else
        cout << "Juego terminado por el jugador.\n";

    return 0;
}
```

---

### Bloque 5 — Objetos en el mapa, inventario y recolección

Objetivo del bloque
Agregar objetos (`struct Objeto`) que el jugador pueda recolectar y guardar en un `vector<string>` como inventario.

Qué se agrega

* `struct Objeto`.
* Lista de objetos en el nivel.
* Recolección al pasar por su posición.

#### Código completo del Bloque 5

```cpp
// Bloque 5: Objetos en el mapa e inventario
// Compilar en Windows

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <conio.h>

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

struct Enemigo {
    int x;
    int y;
    int dx;
    int dy;
    unsigned long ultimaActualizacion;
};

struct Objeto {
    int x;
    int y;
    char simbolo;
    string nombre;
    bool activo;
};

unsigned long millis() {
    using namespace chrono;
    return duration_cast<milliseconds>(
        steady_clock::now().time_since_epoch()
    ).count();
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

void moverEnemigo(Enemigo& e, const vector<string>& mapa, unsigned long intervalo) {
    unsigned long ahora = millis();
    if (ahora - e.ultimaActualizacion >= intervalo) {
        int nx = e.x + e.dx;
        int ny = e.y + e.dy;
        if (esPared(mapa, nx, ny)) {
            e.dx = -e.dx;
            e.dy = -e.dy;
        } else {
            e.x = nx;
            e.y = ny;
        }
        e.ultimaActualizacion = ahora;
    }
}

void recogerObjetos(Jugador& j, vector<Objeto>& objetos, vector<string>& inventario) {
    for (auto& obj : objetos) {
        if (obj.activo && obj.x == j.x && obj.y == j.y) {
            obj.activo = false;
            inventario.push_back(obj.nombre);
            j.puntos += 10; // puntos por objeto
        }
    }
}

void dibujar(const vector<string>& mapa, const Jugador& j, const Enemigo& e,
             const vector<Objeto>& objetos, const vector<string>& inventario) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            bool dibujado = false;

            if (x == j.x && y == j.y) {
                cout << '@';
                dibujado = true;
            } else if (x == e.x && y == e.y) {
                cout << 'X';
                dibujado = true;
            } else {
                for (const auto& obj : objetos) {
                    if (obj.activo && obj.x == x && obj.y == y) {
                        cout << obj.simbolo;
                        dibujado = true;
                        break;
                    }
                }
            }

            if (!dibujado) cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Inventario: ";
    for (auto& item : inventario) cout << "[" << item << "] ";
    cout << "\nMover WASD, 'q' para salir.\n";
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#   K              #",
        "#      ####        #",
        "#         I        #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#        S         #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};
    Enemigo enemigo{15, 5, -1, 0, millis()};
    vector<Objeto> objetos;
    vector<string> inventario;

    // Definir algunos objetos
    objetos.push_back({3, 2, 'K', "Llave", true});
    objetos.push_back({10, 4, 'I', "Insumo", true});
    objetos.push_back({9, 8, 'S', "Sensor", true});

    bool corriendo = true;

    while (corriendo) {
        if (_kbhit()) {
            char tecla = _getch();
            if (tecla == 'q' || tecla == 'Q') {
                corriendo = false;
            } else {
                moverJugador(jugador, tecla, mapa);
            }
        }

        moverEnemigo(enemigo, mapa, 300);
        if (jugador.x == enemigo.x && jugador.y == enemigo.y) {
            jugador.vida -= 1;
            if (jugador.vida <= 0) corriendo = false;
        }

        recogerObjetos(jugador, objetos, inventario);

        dibujar(mapa, jugador, enemigo, objetos, inventario);

        this_thread::sleep_for(chrono::milliseconds(40));
    }

    system("cls");
    if (jugador.vida <= 0)
        cout << "Juego terminado: te quedaste sin vida.\n";
    else
        cout << "Juego terminado por el jugador.\n";

    return 0;
}
```

---

### Bloque 6 — Guardar y cargar estado del juego en archivo

Objetivo del bloque
Permitir guardar y cargar:

* posición, vida, puntos del jugador
* inventario
* posición del enemigo (para simplificar)

Qué se agrega

* `guardarJuego(...)`
* `cargarJuego(...)`

#### Código completo del Bloque 6

```cpp
// Bloque 6: Guardar y cargar partida
// Compilar en Windows

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <conio.h>
#include <fstream>

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

struct Enemigo {
    int x;
    int y;
    int dx;
    int dy;
    unsigned long ultimaActualizacion;
};

struct Objeto {
    int x;
    int y;
    char simbolo;
    string nombre;
    bool activo;
};

unsigned long millis() {
    using namespace chrono;
    return duration_cast<milliseconds>(
        steady_clock::now().time_since_epoch()
    ).count();
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

void moverEnemigo(Enemigo& e, const vector<string>& mapa, unsigned long intervalo) {
    unsigned long ahora = millis();
    if (ahora - e.ultimaActualizacion >= intervalo) {
        int nx = e.x + e.dx;
        int ny = e.y + e.dy;
        if (esPared(mapa, nx, ny)) {
            e.dx = -e.dx;
            e.dy = -e.dy;
        } else {
            e.x = nx;
            e.y = ny;
        }
        e.ultimaActualizacion = ahora;
    }
}

void recogerObjetos(Jugador& j, vector<Objeto>& objetos, vector<string>& inventario) {
    for (auto& obj : objetos) {
        if (obj.activo && obj.x == j.x && obj.y == j.y) {
            obj.activo = false;
            inventario.push_back(obj.nombre);
            j.puntos += 10;
        }
    }
}

void dibujar(const vector<string>& mapa, const Jugador& j, const Enemigo& e,
             const vector<Objeto>& objetos, const vector<string>& inventario) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            bool dibujado = false;

            if (x == j.x && y == j.y) {
                cout << '@';
                dibujado = true;
            } else if (x == e.x && y == e.y) {
                cout << 'X';
                dibujado = true;
            } else {
                for (const auto& obj : objetos) {
                    if (obj.activo && obj.x == x && obj.y == y) {
                        cout << obj.simbolo;
                        dibujado = true;
                        break;
                    }
                }
            }

            if (!dibujado) cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Inventario: ";
    for (auto& item : inventario) cout << "[" << item << "] ";
    cout << "\n";
    cout << "WASD = mover, 'g' = guardar, 'c' = cargar, 'q' = salir.\n";
}

void guardarJuego(const Jugador& j, const Enemigo& e,
                  const vector<string>& inventario) {
    ofstream out("partida.txt");
    if (!out) return;

    out << j.x << " " << j.y << " " << j.vida << " " << j.puntos << "\n";
    out << e.x << " " << e.y << " " << e.dx << " " << e.dy << "\n";
    out << inventario.size() << "\n";
    for (auto& item : inventario) {
        out << item << "\n";
    }
}

bool cargarJuego(Jugador& j, Enemigo& e, vector<string>& inventario) {
    ifstream in("partida.txt");
    if (!in) return false;

    in >> j.x >> j.y >> j.vida >> j.puntos;
    in >> e.x >> e.y >> e.dx >> e.dy;

    int n;
    in >> n;
    in.ignore();
    inventario.clear();
    for (int i = 0; i < n; i++) {
        string item;
        getline(in, item);
        inventario.push_back(item);
    }
    e.ultimaActualizacion = millis();
    return true;
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#   K              #",
        "#      ####        #",
        "#         I        #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#        S         #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};
    Enemigo enemigo{15, 5, -1, 0, millis()};
    vector<Objeto> objetos;
    vector<string> inventario;

    objetos.push_back({3, 2, 'K', "Llave", true});
    objetos.push_back({10, 4, 'I', "Insumo", true});
    objetos.push_back({9, 8, 'S', "Sensor", true});

    bool corriendo = true;

    while (corriendo) {
        if (_kbhit()) {
            char tecla = _getch();
            if (tecla == 'q' || tecla == 'Q') {
                corriendo = false;
            } else if (tecla == 'g' || tecla == 'G') {
                guardarJuego(jugador, enemigo, inventario);
            } else if (tecla == 'c' || tecla == 'C') {
                cargarJuego(jugador, enemigo, inventario);
            } else {
                moverJugador(jugador, tecla, mapa);
            }
        }

        moverEnemigo(enemigo, mapa, 300);

        if (jugador.x == enemigo.x && jugador.y == enemigo.y) {
            jugador.vida -= 1;
            if (jugador.vida <= 0) corriendo = false;
        }

        recogerObjetos(jugador, objetos, inventario);

        dibujar(mapa, jugador, enemigo, objetos, inventario);

        this_thread::sleep_for(chrono::milliseconds(40));
    }

    system("cls");
    if (jugador.vida <= 0)
        cout << "Juego terminado: te quedaste sin vida.\n";
    else
        cout << "Juego terminado por el jugador.\n";

    return 0;
}
```

---

### Bloque 7 — Límite de tiempo y evento de fin de juego

Objetivo del bloque
Agregar un contador de tiempo total. Si se alcanza el límite, el juego termina (evento temporizado sin bloquear la ejecución).

Qué se agrega

* `tInicio = millis()`.
* Comprobación de tiempo en cada iteración.
* Mensaje de derrota por tiempo.

#### Código completo del Bloque 7 (versión final base para el integrador)

```cpp
// Bloque 7: Límite de tiempo y evento de fin de juego
// Versión base final para el integrador de la práctica 6

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <conio.h>
#include <fstream>

using namespace std;

struct Jugador {
    int x;
    int y;
    int vida;
    int puntos;
};

struct Enemigo {
    int x;
    int y;
    int dx;
    int dy;
    unsigned long ultimaActualizacion;
};

struct Objeto {
    int x;
    int y;
    char simbolo;
    string nombre;
    bool activo;
};

unsigned long millis() {
    using namespace chrono;
    return duration_cast<milliseconds>(
        steady_clock::now().time_since_epoch()
    ).count();
}

bool esPared(const vector<string>& mapa, int x, int y) {
    if (y < 0 || y >= (int)mapa.size()) return true;
    if (x < 0 || x >= (int)mapa[y].size()) return true;
    return (mapa[y][x] == '#');
}

void moverJugador(Jugador& j, char tecla, const vector<string>& mapa) {
    int nx = j.x;
    int ny = j.y;

    if (tecla == 'w' || tecla == 'W') ny--;
    if (tecla == 's' || tecla == 'S') ny++;
    if (tecla == 'a' || tecla == 'A') nx--;
    if (tecla == 'd' || tecla == 'D') nx++;

    if (!esPared(mapa, nx, ny)) {
        j.x = nx;
        j.y = ny;
    }
}

void moverEnemigo(Enemigo& e, const vector<string>& mapa, unsigned long intervalo) {
    unsigned long ahora = millis();
    if (ahora - e.ultimaActualizacion >= intervalo) {
        int nx = e.x + e.dx;
        int ny = e.y + e.dy;
        if (esPared(mapa, nx, ny)) {
            e.dx = -e.dx;
            e.dy = -e.dy;
        } else {
            e.x = nx;
            e.y = ny;
        }
        e.ultimaActualizacion = ahora;
    }
}

void recogerObjetos(Jugador& j, vector<Objeto>& objetos, vector<string>& inventario) {
    for (auto& obj : objetos) {
        if (obj.activo && obj.x == j.x && obj.y == j.y) {
            obj.activo = false;
            inventario.push_back(obj.nombre);
            j.puntos += 10;
        }
    }
}

void dibujar(const vector<string>& mapa, const Jugador& j, const Enemigo& e,
             const vector<Objeto>& objetos, const vector<string>& inventario,
             unsigned long segundosRestantes) {
    system("cls");
    for (int y = 0; y < (int)mapa.size(); ++y) {
        for (int x = 0; x < (int)mapa[y].size(); ++x) {
            bool dibujado = false;

            if (x == j.x && y == j.y) {
                cout << '@';
                dibujado = true;
            } else if (x == e.x && y == e.y) {
                cout << 'X';
                dibujado = true;
            } else {
                for (const auto& obj : objetos) {
                    if (obj.activo && obj.x == x && obj.y == y) {
                        cout << obj.simbolo;
                        dibujado = true;
                        break;
                    }
                }
            }

            if (!dibujado) cout << mapa[y][x];
        }
        cout << '\n';
    }
    cout << "Vida: " << j.vida << "  Puntos: " << j.puntos << "\n";
    cout << "Inventario: ";
    for (auto& item : inventario) cout << "[" << item << "] ";
    cout << "\nTiempo restante: " << segundosRestantes << " s\n";
    cout << "WASD = mover, 'g' = guardar, 'c' = cargar, 'q' = salir.\n";
}

void guardarJuego(const Jugador& j, const Enemigo& e,
                  const vector<string>& inventario) {
    ofstream out("partida.txt");
    if (!out) return;

    out << j.x << " " << j.y << " " << j.vida << " " << j.puntos << "\n";
    out << e.x << " " << e.y << " " << e.dx << " " << e.dy << "\n";
    out << inventario.size() << "\n";
    for (auto& item : inventario) out << item << "\n";
}

bool cargarJuego(Jugador& j, Enemigo& e, vector<string>& inventario) {
    ifstream in("partida.txt");
    if (!in) return false;

    in >> j.x >> j.y >> j.vida >> j.puntos;
    in >> e.x >> e.y >> e.dx >> e.dy;
    int n;
    in >> n;
    in.ignore();
    inventario.clear();
    for (int i = 0; i < n; i++) {
        string item;
        getline(in, item);
        inventario.push_back(item);
    }
    e.ultimaActualizacion = millis();
    return true;
}

int main() {
    vector<string> mapa = {
        "####################",
        "#                  #",
        "#   K              #",
        "#      ####        #",
        "#         I        #",
        "#   #######        #",
        "#                  #",
        "#                  #",
        "#        S    E    #",
        "####################"
    };

    Jugador jugador{2, 2, 100, 0};
    Enemigo enemigo{15, 5, -1, 0, millis()};
    vector<Objeto> objetos;
    vector<string> inventario;

    // E: posición objetivo de salida
    int salidaX = 14;
    int salidaY = 8;

    objetos.push_back({3, 2, 'K', "Llave", true});
    objetos.push_back({10, 4, 'I', "Insumo", true});
    objetos.push_back({9, 8, 'S', "Sensor", true});

    bool corriendo = true;
    bool gano = false;

    const unsigned long LIMITE_TIEMPO = 60; // segundos
    unsigned long tInicio = millis();

    while (corriendo) {
        unsigned long ahora = millis();
        unsigned long segundosTranscurridos = (ahora - tInicio) / 1000;
        unsigned long segundosRestantes = (segundosTranscurridos >= LIMITE_TIEMPO)
                                          ? 0 : (LIMITE_TIEMPO - segundosTranscurridos);

        if (segundosRestantes == 0) {
            corriendo = false;
            break;
        }

        if (_kbhit()) {
            char tecla = _getch();
            if (tecla == 'q' || tecla == 'Q') {
                corriendo = false;
            } else if (tecla == 'g' || tecla == 'G') {
                guardarJuego(jugador, enemigo, inventario);
            } else if (tecla == 'c' || tecla == 'C') {
                cargarJuego(jugador, enemigo, inventario);
            } else {
                moverJugador(jugador, tecla, mapa);
            }
        }

        moverEnemigo(enemigo, mapa, 300);

        if (jugador.x == enemigo.x && jugador.y == enemigo.y) {
            jugador.vida -= 1;
            if (jugador.vida <= 0) corriendo = false;
        }

        recogerObjetos(jugador, objetos, inventario);

        // Condición de victoria: llegar a la salida
        if (jugador.x == salidaX && jugador.y == salidaY) {
            gano = true;
            corriendo = false;
        }

        dibujar(mapa, jugador, enemigo, objetos, inventario, segundosRestantes);

        this_thread::sleep_for(chrono::milliseconds(40));
    }

    system("cls");

    if (gano) {
        cout << "Felicidades, llegaste a la salida a tiempo.\n";
        cout << "Puntos finales: " << jugador.puntos << "\n";
    } else if (jugador.vida <= 0) {
        cout << "Juego terminado: te quedaste sin vida.\n";
    } else {
        cout << "Juego terminado: se acabo el tiempo.\n";
    }

    return 0;
}
```

---


