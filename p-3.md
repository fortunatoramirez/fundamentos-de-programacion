
# Práctica 3 — Decisiones y Repetición en C++ con problemas reales

> **Propósito.** Dominar el uso de **condicionales** y **bucles** en C++ para tomar decisiones, validar datos y repetir procesos de forma controlada, resolviendo problemas prácticos del ámbito biomédico y de manufactura.

---

## 1) Objetivo general

Aplicar **estructuras de decisión** (`if/else`, `if-else-if`, `switch`) y **estructuras de repetición** (`while`, `do-while`, `for`) en C++ para resolver problemas reales con entradas validadas, salidas claras y lógica robusta.

---

## 2) Marco teórico

### 2.1 Operadores relacionales y lógicos

* **Relacionales:** `==`, `!=`, `<`, `>`, `<=`, `>=` → producen `true/false`.
* **Lógicos:** `&&` (AND), `||` (OR), `!` (NOT).
* **Precedencia común:** aritméticos > relacionales > lógicos; use paréntesis para claridad.

### 2.2 Estructuras de decisión

* **`if (condición) { ... } else { ... }`**
* **Escalera** `if-else-if` para clasificaciones por rangos.
* **`switch (expresión)`**: decisiones por **casos discretos** (enteros/char); usar `break`.

### 2.3 Estructuras de repetición

* **`while (condición)`**: se evalúa **antes** de entrar; 0 o más repeticiones.
* **`do { ... } while (condición);`**: se ejecuta **al menos una vez**.
* **`for (inicio; condición; actualización)`**: útil para contadores conocidos.

### 2.4 Validación de entradas

* Comprobar rangos válidos (p. ej., `temperatura > 30 && temperatura < 45`).
* Evitar divisiones entre cero.
* Repetir captura hasta que sea válida (bucles).

> **Buenas prácticas:** mensajes claros, uso de `const` para umbrales, formateo con `<iomanip>`, y comentarios breves.

---

## 3) Desarrollo de la práctica

Cada bloque debe incluir:

1. **Pseudocódigo**
2. **Diagrama de flujo** (Inicio/Fin, Entrada, Proceso, Decisión, Salida)
3. **Código C++**

Se sugiere usar [diagrams.net](https://www.diagrams.net/) para los diagramas.

---

## 4) Bloques de actividades

### Bloque 1 — Validación de temperatura corporal (if/else + rangos)

**Problema real:** El triage debe validar una temperatura ingresada (°C).

* **Rango aceptable:** `30.0 < T < 45.0`.
* Si está fuera del rango, indicar “valor no plausible”; si está dentro: clasificar **Hipotermia** `< 35.0`, **Normal** `35.0–37.5`, **Fiebre** `> 37.5`.

**Pseudocódigo**

```
INICIO
  LEER T
  SI (T <= 30.0 O T >= 45.0) ENTONCES
     ESCRIBIR "Temperatura no plausible"
  SINO
     SI (T < 35.0) ENTONCES
        ESCRIBIR "Hipotermia"
     SINO SI (T <= 37.5) ENTONCES
        ESCRIBIR "Rango normal"
     SINO
        ESCRIBIR "Fiebre"
     FIN_SI
  FIN_SI
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

int main() {
    double T;
    cout << "Temperatura (°C): ";
    cin >> T;

    if (T <= 30.0 || T >= 45.0) {
        cout << "Temperatura no plausible" << endl;
    } else if (T < 35.0) {
        cout << "Hipotermia" << endl;
    } else if (T <= 37.5) {
        cout << "Rango normal" << endl;
    } else {
        cout << "Fiebre" << endl;
    }
    return 0;
}
```

---

### Bloque 2 — Clasificación de IMC (if-else-if)

**Problema real:** Además de calcular IMC, mostrar **categoría** (OMS simplificada):

* `<18.5`: Bajo peso
* `18.5–24.9`: Normal
* `25.0–29.9`: Sobrepeso
* `>=30.0`: Obesidad

**Pseudocódigo**

```
INICIO
  LEER peso, estatura
  imc ← peso / (estatura * estatura)
  SI (imc < 18.5) ENTONCES ESCRIBIR "Bajo peso"
  SINO SI (imc < 25.0) ENTONCES ESCRIBIR "Normal"
  SINO SI (imc < 30.0) ENTONCES ESCRIBIR "Sobrepeso"
  SINO ESCRIBIR "Obesidad"
FIN
```

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double peso, est, imc;
    cout << "Peso (kg) y estatura (m): ";
    cin >> peso >> est;

    imc = peso / (est * est);
    cout << fixed << setprecision(2) << "IMC: " << imc << " -> ";

    if (imc < 18.5)       cout << "Bajo peso\n";
    else if (imc < 25.0)  cout << "Normal\n";
    else if (imc < 30.0)  cout << "Sobrepeso\n";
    else                  cout << "Obesidad\n";
    return 0;
}
```

---

### Bloque 3 — Dosificación pediátrica por peso (if/else + validación)

**Problema real:** Un jarabe se dosifica **mg/kg** (p. ej., 10 mg/kg).

* Entrada: `peso_kg` y **dosis\_mg\_por\_kg**.
* Salida: **dosis total mg** y **ml** según concentración (p. ej., 100 mg en 5 ml).
* Validar: `peso_kg` (2–120), dosis por kg (1–30). Si no, solicitar reintento (bucles en Bloque 6; aquí una validación simple).

**Pseudocódigo**

```
INICIO
  LEER peso, dosisKg, mgPor5ml
  dosisTotalMg ← peso * dosisKg
  ml ← (dosisTotalMg * 5) / mgPor5ml
  ESCRIBIR dosisTotalMg, ml
FIN
```

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double peso, dosisKg, mgPor5ml;
    cout << "Peso(kg), dosis(mg/kg) y concentracion (mg por 5 ml): ";
    cin >> peso >> dosisKg >> mgPor5ml;

    if (peso < 2 || peso > 120 || dosisKg < 1 || dosisKg > 30 || mgPor5ml <= 0) {
        cout << "Entradas fuera de rango.\n";
        return 0;
    }
    double dosisMg = peso * dosisKg;
    double ml = (dosisMg * 5.0) / mgPor5ml;

    cout << fixed << setprecision(2);
    cout << "Dosis total: " << dosisMg << " mg (" << ml << " ml)\n";
    return 0;
}
```

---

### Bloque 4 — Tarifa por consumo eléctrico escalonado (if-else-if)

**Problema real:** Una clínica paga energía según **escalones** (ejemplo didáctico):

* 0–150 kWh: \$1.00/kWh
* 151–300 kWh: \$1.20/kWh
* > 300 kWh: \$1.50/kWh
  > Calcular el **monto** del periodo.

**Pseudocódigo**

```
INICIO
  LEER kwh
  SI (kwh < 0) -> "Entrada invalida"
  SINO SI (kwh <= 150) costo ← kwh * 1.00
  SINO SI (kwh <= 300) costo ← kwh * 1.20
  SINO costo ← kwh * 1.50
  ESCRIBIR costo
FIN
```

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double kwh, costo;
    cout << "Consumo (kWh): ";
    cin >> kwh;

    if (kwh < 0) {
        cout << "Entrada invalida\n";
        return 0;
    } else if (kwh <= 150) {
        costo = kwh * 1.00;
    } else if (kwh <= 300) {
        costo = kwh * 1.20;
    } else {
        costo = kwh * 1.50;
    }

    cout << fixed << setprecision(2) << "Costo: $" << costo << endl;
    return 0;
}
```

---

### Bloque 5 — Enrutamiento de muestras por tipo (switch)

**Problema real:** El laboratorio etiqueta muestras:

* `S/s` sangre, `U/u` orina, `P/p` plasma, `T/t` tejido.
  Con `switch`, indicar a qué **estación** se envía.

**Pseudocódigo**

```
INICIO
  LEER tipo (char)
  SEGUN(tipo)
    'S'|'s' -> "Hematologia"
    'U'|'u' -> "Uroanalisis"
    'P'|'p' -> "Bioquimica"
    'T'|'t' -> "Histologia"
    OTRO    -> "Tipo no reconocido"
  FIN_SEGUN
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

int main() {
    char t;
    cout << "Tipo de muestra (S/U/P/T): ";
    cin >> t;

    switch (t) {
        case 'S': case 's': cout << "Hematologia\n"; break;
        case 'U': case 'u': cout << "Uroanalisis\n"; break;
        case 'P': case 'p': cout << "Bioquimica\n"; break;
        case 'T': case 't': cout << "Histologia\n"; break;
        default:            cout << "Tipo no reconocido\n";
    }
    return 0;
}
```

---

### Bloque 6 — Reintento hasta dato válido (do-while)

**Problema real:** Capturar **frecuencia cardiaca (FC)** plausible (40–220 lpm). Repetir mientras sea inválida.

**Pseudocódigo**

```
INICIO
  REPETIR
    LEER fc
    valido ← (fc >= 40 Y fc <= 220)
    SI NO valido ENTONCES ESCRIBIR "Valor invalido"
  HASTA QUE valido = VERDADERO
  ESCRIBIR "FC capturada:", fc
FIN
```

**Código C++**

```cpp
#include <iostream>
using namespace std;

int main() {
    int fc;
    bool valido;
    do {
        cout << "Frecuencia cardiaca (40-220 lpm): ";
        cin >> fc;
        valido = (fc >= 40 && fc <= 220);
        if (!valido) cout << "Valor invalido, intente de nuevo.\n";
    } while (!valido);

    cout << "FC capturada: " << fc << " lpm\n";
    return 0;
}
```

---

### Bloque 7 — Promedio de N lecturas de glucosa (for)

**Problema real:** Calcular el **promedio** de `N` mediciones de glucosa capilar (mg/dL). Validar cada lectura en `40–500`.

**Pseudocódigo**

```
INICIO
  LEER N
  suma ← 0
  PARA i ← 1 HASTA N HACER
     LEER g
     SI (g < 40 O g > 500) ENTONCES
        ESCRIBIR "Lectura fuera de rango"; CONTINUAR
     FIN_SI
     suma ← suma + g
     cont ← cont + 1
  FIN_PARA
  SI cont > 0 ENTONCES prom ← suma / cont
  ESCRIBIR prom
FIN
```

**Código C++**

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int N, cont = 0;
    double g, suma = 0.0;

    cout << "Numero de lecturas: ";
    cin >> N;

    for (int i = 1; i <= N; ++i) {
        cout << "Glucosa " << i << " (40-500 mg/dL): ";
        cin >> g;
        if (g < 40 || g > 500) {
            cout << "Fuera de rango. Se omite.\n";
            continue;
        }
        suma += g;
        cont++;
    }
    if (cont > 0) {
        cout << fixed << setprecision(1);
        cout << "Promedio valido (" << cont << " lecturas): " << (suma/cont) << " mg/dL\n";
    } else {
        cout << "No hay lecturas validas.\n";
    }
    return 0;
}
```

---

## 5) Ejercicio integrador (sin pseudocódigo ni código aquí)

**Menú de monitoreo básico** (con `do-while` + `switch`)

Construir un programa con **menú** que se repita hasta que el usuario elija “Salir”. Debe ofrecer al menos estas opciones:

1. **Validar temperatura** (Bloque 1).
2. **Calcular IMC y categoría** (Bloque 2).
3. **Dosificación pediátrica** (Bloque 3).
4. **Promedio de glucosa** (Bloque 7).
5. **Salir**.

**Requisitos mínimos:**

* Usar `do-while` para repetir el menú.
* Usar `switch` para las opciones.
* Validar entradas (reutilizando la lógica de los bloques).
* Formatear salidas con claridad.

**Evidencias a entregar:**

* **Pseudocódigo** del menú y de cada opción.
* **Diagrama de flujo** del menú (y subdiagramas si lo desean).
* **Capturas de ejecución** (probar cada opción al menos una vez).

---

## 6) Preguntas de reflexión

1. ¿Cuándo conviene `if-else-if` en lugar de `switch` y viceversa?
2. ¿Por qué `do-while` garantiza **al menos una** iteración y en qué casos es útil?
3. ¿Qué problemas evita la **validación de rangos** antes de operar? Da dos ejemplos.
4. Explica con tus palabras el uso de `continue` en el Bloque 7 y una alternativa sin `continue`.

---

## 7) Evidencias para la bitácora

* Foto(s) de **pseudocódigos** de cada bloque.
* Imagen(es) de **diagramas de flujo**.
* **Capturas** de las ejecuciones (mínimo 1 por bloque y todas las opciones del menú integrador).
* Respuestas a las **preguntas de reflexión**.

---

## 8) Compilación y ejecución (recordatorio)

```bash
g++ -std=c++17 main.cpp -o main
./main
```

En Code::Blocks: **F9**.

